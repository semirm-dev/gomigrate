package cmd

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"

	"github.com/dave/jennifer/jen"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"
)

// Template migration command
var Template = &cobra.Command{
	Use:   "tpl",
	Short: "Generate templates",
	Long:  `Generate templates`,
	Run: func(cmd *cobra.Command, args []string) {
		createPath(migrationsDest, cmdDest)

		createConfigFile("https://raw.githubusercontent.com/semirm-dev/gomigrate/master/cmd/config.yml", cmdDest+"/config.yml")

		parseConfigFile(cmdDest + "/config.yml")

		createRegisterMigrationsCollection()

		createApplyCmd()

		logrus.Info("templates generated")
	},
}

func createConfigFile(src, dest string) {
	if _, err := os.Stat(dest); os.IsNotExist(err) {
		if err := downloadFile(src, dest); err != nil {
			logrus.Fatal("failed to get config.yml: ", err)
		}
	}

}

func parseConfigFile(path string) {
	configYml, err := ioutil.ReadFile(path)
	if err != nil {
		logrus.Fatalf("failed to read config.yml: %v", err)
	}

	err = yaml.Unmarshal(configYml, &Conf)
	if err != nil {
		logrus.Fatalf("failed to unmarshal config.yml: %v", err)
	}
}

func createRegisterMigrationsCollection() {
	dest := migrationsDest + "/registermigrations.go"

	if _, err := os.Stat(dest); os.IsNotExist(err) {
		m := jen.NewFile(migrationsDest)

		m.ImportAlias(gomigrateLib, "gomigrateLib")

		printAutoGeneratedNote(m)

		m.Comment("Collection with all migrations")
		m.Var().Id("Collection").Op("=").Index().Qual(gomigrateLib, "MigrationDefinition").Block()

		c := []byte(fmt.Sprintf("%#v", m))

		writeFileContent(dest, c)
	}
}

func createApplyCmd() {
	dest := cmdDest + "/migration.go"

	if _, err := os.Stat(dest); os.IsNotExist(err) {
		m := jen.NewFile(cmdDest)

		m.ImportAlias(gomigrateLib, "gomigrateLib")

		printAutoGeneratedNote(m)

		m.Func().Id("init").Params().Block(
			jen.Qual("", "Migration.AddCommand").Call(jen.Id("Apply")),
		)

		m.Comment("Migration command")
		m.Var().Id("Migration").Op("= &").Qual(cobraLib, "Command").Values(
			jen.Dict{
				jen.Id("Use"):   jen.Lit(""),
				jen.Id("Short"): jen.Lit("Migrations tool"),
				jen.Id("Long"):  jen.Lit("`Migrations tool`"),
				jen.Id("Run"):   jen.Func().Params(jen.Id("cmd").Op("*").Qual(cobraLib, "Command"), jen.Id("agrs").Index().String()).Block(),
			},
		)

		m.Comment("Apply command")
		m.Var().Id("Apply").Op("= &").Qual(cobraLib, "Command").Values(
			jen.Dict{
				jen.Id("Use"):   jen.Lit("migrate"),
				jen.Id("Short"): jen.Lit("Apply migrations"),
				jen.Id("Long"):  jen.Lit("`Apply migrations`"),
				jen.Id("Run"): jen.Func().Params(jen.Id("cmd").Op("*").Qual(cobraLib, "Command"), jen.Id("agrs").Index().String()).Block(
					jen.Qual(gomigrateLib, "Run").Call(jen.Qual(Conf.Pkg+"/"+migrationsDest, "Collection")),
					jen.Qual(logrusLib, "Info").Call(jen.Lit("migrations script finished")),
				),
			},
		)

		c := []byte(fmt.Sprintf("%#v", m))

		writeFileContent(dest, c)
	}
}

func downloadFile(src string, dest string) error {
	resp, err := http.Get(src)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	out, err := os.Create(dest)
	if err != nil {
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)

	return err
}
