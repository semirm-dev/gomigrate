package cmd

import (
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"sort"
	"time"

	"github.com/dave/jennifer/jen"
	"github.com/jinzhu/gorm"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"
)

const (
	gomigrateLib = "github.com/semirm-dev/gomigrate/cmd"
	goDevLib     = "github.com/semirm-dev/go-dev"
	logrusLib    = "github.com/sirupsen/logrus"
	gormLib      = "github.com/jinzhu/gorm"
	cobraLib     = "github.com/spf13/cobra"
)

var (
	migrationsDest = "migrations"
	cmdDest        = "cmd"
)

// Migration root command
var Migration = &cobra.Command{
	Use:   "",
	Short: "Migration tool",
	Long:  `Migration tool`,
}

// MigrationDefinition for each migration
type MigrationDefinition interface {
	Name() string
	Apply(*gorm.DB) error
	Rollback(*gorm.DB) error
	Timestamp() int64
}

// Config for database connection
type Config struct {
	Database struct {
		Dialect    string `yaml:"dialect"`
		ConnString string `yaml:"connstring"`
	} `yaml:"database"`
}

// migration represents single row in migrations table
type migration struct {
	ID        uint `gorm:"primary_key"`
	Name      string
	Timestamp int64
	CreatedAt time.Time
}

// Run migrations collection
func Run(collection []MigrationDefinition, conf Config) {
	db, err := gorm.Open(conf.Database.Dialect, conf.Database.ConnString)
	if err != nil {
		logrus.Fatal(err)
	}
	defer db.Close()

	db.AutoMigrate(&migration{})

	sort.Slice(collection, func(i, j int) bool {
		return collection[i].Timestamp() < collection[j].Timestamp()
	})

	migrations := getMigrationsHistory(db)

	for _, c := range collection {
		if !applied(c, migrations) {
			if err := c.Apply(db); err != nil {
				logrus.Errorf("migration %s failed to apply: %v", c.Name(), err)
				break
			}

			if err := saveMigrationHistory(c, db); err != nil {
				logrus.Warnf("failed to record migration %s: %v", c.Name(), err)

				if err := c.Rollback(db); err != nil {
					logrus.Errorf("migration %s failed to rollback: %v", c.Name(), err)
					break
				}

				logrus.Warnf("migration %s rolled back", c.Name())

				break
			}

			logrus.Infof("migration %s applied", c.Name())
		}
	}
}

// ParseConfig file
func ParseConfig(path string) Config {
	configYml, err := ioutil.ReadFile(path)
	if err != nil {
		logrus.Fatalf("failed to read config.yml: %v", err)
	}

	config := Config{}

	err = yaml.Unmarshal(configYml, &config)
	if err != nil {
		logrus.Fatalf("failed to unmarshal config.yml: %v", err)
	}

	return config
}

func applied(mig MigrationDefinition, migrations []*migration) bool {
	for _, m := range migrations {
		if mig.Timestamp() == m.Timestamp {
			return true
		}
	}

	return false
}

func getMigrationsHistory(db *gorm.DB) []*migration {
	var migrations = []*migration{}

	db.Find(&migrations)

	return migrations
}

func saveMigrationHistory(m MigrationDefinition, db *gorm.DB) error {
	return db.Create(&migration{
		Name:      m.Name(),
		Timestamp: m.Timestamp(),
	}).Error
}

func writeFileContent(path string, content []byte) {
	if err := ioutil.WriteFile(path, content, 0644); err != nil {
		logrus.Fatal("write content to file failed: ", err)
	}
}

func createPath(path ...string) {
	for _, p := range path {
		if _, err := os.Stat(p); os.IsNotExist(err) {
			if err := os.MkdirAll(p, os.ModePerm); err != nil {
				logrus.Fatalf("failed to create %s directory: %v", p, err)
			}
		}
	}
}

func createConfigFile(src, dest string) {
	if _, err := os.Stat(dest); os.IsNotExist(err) {
		if err := downloadFile(src, dest); err != nil {
			logrus.Fatal("failed to get config.yml: ", err)
		}
	}
}

func downloadFile(src, dest string) error {
	resp, err := http.Get(src)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	out, err := os.Create(dest)
	if err != nil {
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)

	return err
}

func printAutoGeneratedNote(m *jen.File) {
	m.Comment("Auto-generated file: https://github.com/semirm-dev/gomigrate")
	m.Comment("Feel free to edit")
	m.Line()
}
