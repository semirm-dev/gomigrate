package cmd

import (
	"fmt"
	"strings"
	"time"

	"github.com/dave/jennifer/jen"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
)

// Create migration command
var Create = &cobra.Command{
	Use:   "create",
	Short: "Create migration",
	Long:  `Create migration`,
	Run: func(cmd *cobra.Command, args []string) {
		var name = strings.TrimSpace(cmd.Flag("migration").Value.String())

		if name == "" {
			logrus.Fatal("invalid migration name")
		}

		m := jen.NewFile(migrationsDest)

		printAutoGeneratedNote(m)

		m.Comment(name + " migration")
		m.Type().Id(name).Struct()

		m.Comment("Apply migration")
		m.Func().Params(jen.Id("mig").Id("*"+name)).Id("Apply").Params(jen.Id("db").Op("*").Qual(gormLib, "DB")).Error().Block(
			jen.Qual(logrusLib, "Info").Call(jen.Lit("Applying migration")),
			jen.Return(jen.Nil()),
		)

		m.Comment("Rollback migration")
		m.Func().Params(jen.Id("mig").Id("*"+name)).Id("Rollback").Params(jen.Id("db").Op("*").Qual(gormLib, "DB")).Error().Block(
			jen.Qual(logrusLib, "Info").Call(jen.Lit("Rolling back migration")),
			jen.Return(jen.Nil()),
		)

		ts := time.Now().Unix()

		m.Comment("Timestamp when migration was created")
		m.Func().Params(jen.Id("mig").Id("*" + name)).Id("Timestamp").Params().Int64().Block(
			jen.Return(jen.Lit(ts)),
		)

		m.Comment("Name of migration")
		m.Func().Params(jen.Id("mig").Id("*" + name)).Id("Name").Params().String().Block(
			jen.Return(jen.Lit(name)),
		)

		n := migrationsDest + "/" + strings.ToLower(fmt.Sprint(ts)+"_"+name+".go")
		c := []byte(fmt.Sprintf("%#v", m))

		writeFileContent(n, c)

		logrus.Infof("migration %s created", name)
	},
}
